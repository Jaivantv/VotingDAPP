# Decentralized Voting System based on Ethereum Blockchain

This project consists of steps that include the **front-end client** originally written using HTML, CSS, JavaScript using the **Bootstrap framework**. The business logic/Smart contract is defined in an IDE that runs on the **Ethereum Virtual Machine (EVM)** called **Remix IDE** using the programming language **Solidity** and the **Injected Web3** environment. The client will connect to the Ethereum block chain (Remix IDE) using the **Metamask** server extension which acts as the intermediary connection service between the client and the blockchain server. Business Logic related to the decentralized application for the Election Smart Contract is coded using the Solidity programming Language. This Smart Contract is deployed to the local Ethereum blockchain and then accounts are created to start voting in a false simulation network generated by metamask. 









![](images/1.png)



**Step 1: Front end connection:** 

The front end is designed using the Bootstrap framework and the front end is connected to the backend using the unique ABI (Application Binary Interface) and the unique address thatâ€™s generated when the smart contract is deployed in the backend IDE that runs on the Ethereum Virtual machine (EVM). 



**Step 2: Smart Contract is created:** 

The smart contract will originally consist of all the business logic of the project. It reads from and writes to the Ethereum blockchain. This consists of information that will run the election, keep a record of the users and will take care of the rules of the election. It is simply a record of conditions necessary to run the project. 



**Step 3: List the Candidates:** 

Solidity allows us to create our own structure types as we've done for our candidate here. We specified that this struct has an id of unsigned integer type, name of string type, and vote Count of unsigned integer type. Simply declaring this struct won't actually give us a candidate. We need to instantiate it and assign it to a variable before we can write it to storage. The next thing we need is a place to store the candidates. We need a place to store one of the structure types that we've just created. We can do this with a [Solidity mapping.](https://solidity.readthedocs.io/en/v0.4.21/types.html?highlight=mapping&mappings)[ ](https://solidity.readthedocs.io/en/v0.4.21/types.html?highlight=mapping&mappings)[A](https://solidity.readthedocs.io/en/v0.4.21/types.html?highlight=mapping&mappings) mapping in Solidity is like an associative array or a hash that associates key-value pairs. We've declared the function addCandidate that takes one argument of string type that represents the candidate's name. Inside the function, we increment the candidate counter cache to denote that a new candidate has been added. 



**Step 4: Get Ether from faucet:** 

` `The voters create an account in Metamask and connect it to the Ethereum server. The voter must import ether from the Metamask faucet into their account to be able to cast their votes.  





![](Aspose.Words.2af16d72-0f7e-4411-ab21-61bc9487f8d1.002.png)















![](Aspose.Words.2af16d72-0f7e-4411-ab21-61bc9487f8d1.003.png)

**Step 5: Cast votes:** 

This helps us to add votes in the election. Once the Ether has been successfully transferred into the individuals account, the individual can cast their vote for which they have to first confirm the transaction followed by the payment of the ether. 







![](Aspose.Words.2af16d72-0f7e-4411-ab21-61bc9487f8d1.004.png)![Graphical user interface, application

Description automatically generated](Aspose.Words.2af16d72-0f7e-4411-ab21-61bc9487f8d1.005.jpeg)



On confirming the payment at a particular set amount of gas and time, the voter can cast their votes to their desired candidate. Once the payment is confirmed, there is a notification saying the transaction was successful and the payment has been deducted from the account. Until then, the payment is pending! 
**

**

**


![](Aspose.Words.2af16d72-0f7e-4411-ab21-61bc9487f8d1.006.png)

![Graphical user interface, website

Description automatically generated](Aspose.Words.2af16d72-0f7e-4411-ab21-61bc9487f8d1.007.jpeg)** 
**


**Step 6: Testing:** 
**


- Test Case 1: Checks that only 2 candidates are totally present, and addition of candidates will result in test case failure. 
- Test Case 2: Check whether the name, vote count and candidate id is correct. 
- Test Case 3: Test that the function increments the vote count for the candidate when a vote is added. Test that the voter gets added to the mapping whenever the vote count increases. 
- Test Case 4: To ensure that we prevent vote count from invalid candidates. 
- Test Case 5: Test to ensure that we prevent double voting. 

